@startuml

title Fluxo usando Jenkins + HELM de CICD no ambiente de Qualidade

autonumber

participant "source-code" as source << Bitbucket >> #LightGrey
participant "Jenkins" as jenkinsDev << DEV >> #LightBlue
participant Nexus as nexus << Repository >> #DarkCyan
participant "GitOps" as config << Bitbucket >> #Plum
participant "Jenkins" as jenkinsProd<< QA >> #LightGreen
participant "Openshift" as ocp << nodeSelector=AMBIENTE >>

[-> source: Push
activate jenkinsDev
== CI ==
source -> jenkinsDev: <<webhooks>> start job
note right: ocorre apenas para BRANCH: release/*

    jenkinsDev --> jenkinsDev: BRANCH_NAME: getBranchName
    jenkinsDev --> jenkinsDev: COMMIT_HASH: getHashCommit
    jenkinsDev --> jenkinsDev: PROJETO: getNomeProjeto
    jenkinsDev --> jenkinsDev: AMBIENTE: getAmbiente
    jenkinsDev --> jenkinsDev: APP_NAME: getNomeAplicação
    jenkinsDev --> source: git clone (${BRANCH_NAME})
group Pipeline por Tecnologia
    jenkinsDev --> jenkinsDev: mvn package
    jenkinsDev --> jenkinsDev: mvn test
    jenkinsDev --> jenkinsDev: image-build
    jenkinsDev --> jenkinsDev: VERSAO_IMAGEM = ${BRANCH_NAME}-${COMMIT_HASH}
    jenkinsDev --> nexus: tagImage ($PROJETO, $VERSAO_IMAGEM)
end

group Atualizar Versão Imagem no ambiente de QUALIDADE
    jenkinsDev --> config: git clone branch ${AMBIENTE}
    jenkinsDev --> jenkinsDev: VALUES = ${PROJETO}/${APP_NAME}/values-${BRANCH_NAME}.yaml
    jenkinsDev --> jenkinsDev: yq eval "(.app.image.tag)|=\"$VERSAO_IMAGEM\"" -i ${VALUES}
    note right: deverá criar o arquivo caso não exista!

    jenkinsDev --> config: git commit -a "[JENKINS] atualizado versao da imagem"
    jenkinsDev --> config: git push
end

group Atualizar Versão Imagem no ambiente de PRODUÇÃO
    jenkinsDev --> config: git clone branch PRD
    jenkinsDev --> jenkinsDev: VALUES = ${PROJETO}/${APP_NAME}/values-PRD.yaml
    jenkinsDev --> jenkinsDev: yq eval "(.app.image.tag)|=\"$VERSAO_IMAGEM\"" -i ${VALUES}
    note right: deverá criar o arquivo caso não exista!

    jenkinsDev --> config: git commit -a "[JENKINS] atualizado versao da imagem"
    jenkinsDev --> config: git push
end

deactivate jenkinsDev

== CD ==
[-> jenkinsProd: JOB Aprovar para Qualidade (${BRANCH_NAME}))
activate jenkinsProd

jenkinsProd -> source: git MERGE VALIDATE ${BRANCH_NAME} com MASTER
note right: a depender do processo poderá abortar ou continuar

jenkinsProd -> config: git clone branch ${AMBIENTE}
jenkinsProd --> jenkinsProd: TEMPLATE=${PROJETO}/${APP_NAME}
jenkinsProd --> jenkinsProd: helm template $TEMPLATE -f $TEMPLATE/values-${TAG_NAME}.yaml --output-dir target

jenkinsProd --> jenkinsProd: NAMESPACE=${PROJETO}-${AMBIENTE}
jenkinsProd -> ocp: oc -n ${NAMESPACE} apply -f -R target/
activate ocp
deactivate ocp
deactivate jenkinsProd

[->jenkinsProd: JOB gerar Tag GitOps e RELEASE da IMAGEM - SEMPRE antes de promover PRODUÇÃO
activate jenkinsProd
jenkinsProd -> source: git MERGE VALIDATE ${BRANCH_NAME} com MASTER
note right: a depender do processo poderá abortar ou continuar

jenkinsProd -> config: gerarTagGit
jenkinsProd -> jenkinsProd: SNAPSHOT TO RELEASE
deactivate jenkinsProd

[-> jenkinsProd: JOB Aprovar para PRODUÇÃO (${TAG_NAME}))
activate jenkinsProd

jenkinsProd -> config: git clone branch ${AMBIENTE}
jenkinsProd --> jenkinsProd: TEMPLATE=${PROJETO}/${APP_NAME}
jenkinsProd --> jenkinsProd: helm template $TEMPLATE -f $TEMPLATE/values-PRD.yaml --output-dir target

jenkinsProd --> jenkinsProd: NAMESPACE=${PROJETO}-${AMBIENTE}
jenkinsProd -> ocp: oc -n ${NAMESPACE} apply -f -R target/
activate ocp
deactivate ocp
deactivate jenkinsProd

@enduml
